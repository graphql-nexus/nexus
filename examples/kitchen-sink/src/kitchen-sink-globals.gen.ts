/** This file was generated by Nexus Schema Do not make changes to this file directly */

import type { NexusGenTypes } from './kitchen-sink.gen'
declare global {
  interface NexusGenCustomInputMethods<TypeName extends string> {
    date<FieldName extends string>(
      fieldName: FieldName,
      opts?: core.CommonInputFieldConfig<TypeName, FieldName>
    ): void // "Date";
  }
}
declare global {
  interface NexusGenCustomOutputMethods<TypeName extends string> {
    date<FieldName extends string>(
      fieldName: FieldName,
      ...opts: core.ScalarOutSpread<TypeName, FieldName>
    ): void // "Date";
    /**
     * Adds a Relay-style connection to the type, with numerous options for configuration
     *
     * @see https://nexusjs.org/docs/plugins/connection
     */
    connectionField<FieldName extends string>(
      fieldName: FieldName,
      config: connectionPluginCore.ConnectionFieldConfig<TypeName, FieldName>
    ): void
  }
}

declare global {
  interface NexusGen extends NexusGenTypes {}
}

import type { core, connectionPluginCore } from 'nexus'
import type { QueryComplexity } from 'nexus/dist/plugins/queryComplexityPlugin'
import type { FieldAuthorizeResolver } from 'nexus/dist/plugins/fieldAuthorizePlugin'

declare global {
  interface NexusGenPluginTypeConfig<TypeName extends string> {
    node?: string | core.FieldResolver<TypeName, any>
  }
  interface NexusGenPluginInputTypeConfig<TypeName extends string> {}
  interface NexusGenPluginFieldConfig<TypeName extends string, FieldName extends string> {
    /**
     * The complexity for an individual field. Return a number or a function that returns a number to specify
     * the complexity for this field.
     */
    complexity?: QueryComplexity<TypeName, FieldName>
    /**
     * Authorization for an individual field. Returning "true" or "Promise<true>" means the field can be
     * accessed. Returning "false" or "Promise<false>" will respond with a "Not Authorized" error for the
     * field. Returning or throwing an error will also prevent the resolver from executing.
     */
    authorize?: FieldAuthorizeResolver<TypeName, FieldName>
    /**
     * The nullability guard can be helpful, but is also a potentially expensive operation for lists. We need
     * to iterate the entire list to check for null items to guard against. Set this to true to skip the null
     * guard on a specific field if you know there's no potential for unsafe types.
     */
    skipNullGuard?: boolean
  }
  interface NexusGenPluginInputFieldConfig<TypeName extends string, FieldName extends string> {}
  interface NexusGenPluginSchemaConfig {}
  interface NexusGenPluginArgConfig {}
}
