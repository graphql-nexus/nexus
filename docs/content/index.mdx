---
title: 'Nexus Documentation'
metaTitle: 'Nexus Documentation (Concepts, Reference & Guides)'
metaDescription: ''
---

## Welcome!

Robust, composable type definition for GraphQL in TypeScript/JavaScript.

> **Note:**
> The documentation is very new and may contain some gaps, please help us fill them in by opening issues or better yet, pull-requests when you think something could be explained better. The [examples](https://github.com/graphql-nexus/schema/tree/develop/examples) are a great place to look to better understand how the library can be used.

Nexus aims to combine the simplicity and ease of development of SDL development approaches like [graphql-tools](https://www.apollographql.com/docs/graphql-tools/generate-schema.html) with the long-term maintainability of programmatic construction, as seen in [graphene-python](https://docs.graphene-python.org/en/latest/), [graphql-ruby](https://github.com/rmosolgo/graphql-ruby), or [graphql-js](https://github.com/graphql/graphql-js).

Nexus builds upon the primitives of `graphql-js`, and attempts to take the simplicity of the SDL schema-first approach and pair it with the power of having the full language runtime at your disposal.

Nexus was designed with TypeScript/JavaScript intellisense in mind, and combines TypeScript generics, conditional types, and type merging to provide full auto-generated type coverage out of the box.

Check out the [example projects](https://github.com/graphql-nexus/schema/tree/develop/examples) to get some ideas of what this looks like in practice, or try it out in the [playground](https://nxs.li/tools/playground) to see what we mean!

## Installation

```sh
npm add @nexus/schema
npm add graphql # required as a peer dependency
```

## Example

As documented in the [API reference](/api/introduction) GraphQL Nexus provides a consistent, scalable approach to defining GraphQL types in code.

```js
import {
  arg,
  enumType,
  intArg,
  interfaceType,
  objectType,
  queryType,
  stringArg,
} from '@nexus/schema'

export const Node = interfaceType({
  name: 'Node',
  definition(t) {
    t.id('id', { description: 'Unique identifier for the resource' })
  },
})

export const Account = objectType({
  name: 'Account',
  isTypeOf(source) {
    return 'email' in source
  },
  definition(t) {
    t.implements(Node) // or t.implements("Node")
    t.string('username')
    t.string('email')
  },
})

export const StatusEnum = enumType({
  name: 'StatusEnum',
  members: ['ACTIVE', 'DISABLED'],
})

export const Query = queryType({
  definition(t) {
    t.field('account', {
      type: Account, // or "Account"
      args: {
        name: stringArg(),
        status: arg({ type: 'StatusEnum' }),
      },
    })
    t.list.field('accountsById', {
      type: Account, // or "Account"
      args: {
        ids: intArg({ list: true }),
      },
    })
  },
})

```
