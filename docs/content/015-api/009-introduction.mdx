---
title: Introduction
---

## Introduction

The API has been carefully designed with the following goals in mind:

1. Type-Safety [by default](/guides/generated-artifacts#typescript-type-generation)
1. Readability
1. Developer ergonomics
1. Playing nicely with Prettier formatting

The API has evolved over the last few months of early development and internal use is unlikely to undergo major structural changes.

That is, before you open a GitHub issue or pull-request with a suggested change to the API, ensure that it meets all four of those criteria listed above and be able to explain why a change is necessary.

Each public API is documented below, feel free to open a PR with more examples/clarification:

- [objectType / queryType / mutationType](/api/object-type)
- [unionType](/api/union-type)
- [interfaceType](/api/interface-type)
- [inputObjectType](/api/input-object-type)
- [enumType](/api/enum-type)
- [scalarType](/api/scalar-type)
- [args](/api/args)
- [makeSchema](/api/make-schema)
- [extendType / extendInputType](/api/extend-type)
- [mutationField](/api/mutation-field)
- [queryField](/api/query-field)

## Resolving: Inline Function

One common idiom in GraphQL is exposing fields that mask or rename the property name on the backing object. GraphQL Nexus makes this simple by allowing a function as the second parameter to any built-in scalar resolver function.

```ts
const User = objectType({
  name: 'User',
  definition(t) {
    t.id('id', o => o.user_id)
    t.string('name', o => o.user_name)
    t.string('description', o => o.user_description)
  },
})
```
